                        КОНСТАНТНОСТЬ В КЛАССЕ
Lesson15CONST.cpp

class A
{
public:
  const int m_Const
  A (int n): m_a (n) {} // A (int n = 0) конструктор и по умолчанию 
                        // и принимающий значение
private:
  int m_a;
}

int main()
{
  A aObj (11);
  A a1Obj (8);
  aObj = a1Obj; // Error, нельзя присвоить значение константе
}

Чтобы не было ошибки: 

1 СПОСОБ:

class A
{
public:
  const int m_Const
  A (int n): m_a (n) {} // A (int n = 0) конструктор и по умолчанию 
                        // и принимающий значение
  A& operator=(const A& R) // поэтому прописываем оператор присваивания
                           // чтобы не было ошибки
  {
    this->~A();
    m_a = R.m_a;
    int *pA = const_cast<int*> (&m_Const); // создаём указатель который может
    *pA = R.m_Const;                       // менять данные по адресу где 
                                           // записана константа
    return *this;
  }
private:
  int m_a;
}

A *pA = new A(8); //создать один объект в динамической памяти
                  //это используется когда объект должен жить за
                  //пределами области видимости в которой был создан

placement new - позволяет отработать конструктором по уже выделенному 
                куску памяти
const int SIZE = 2000;
char *pBuff = new char [SIZE]; // создаём буффер в который будем записывать
                               // разные данные разных типов
A *pA = new (pBuff) A (555);   // вызывая конструкторы в уже выделенной памяти
            (адрес) (данные)   // другим способом нельзя в уже выделенной памяти
                               // вызывать конструктор для создания объекта


2 СПОСОБ:

A& operator=(const A& R) // ещё один способ как прописать оператор присваивания
{                        // когда есть константа в классе с помощью 
  this->~A();            // placement new
  A *pA = new (this) A (R); // смысл в том что мы заново создаём объект с помощью конструктора
  return *this;             // копирования но по тому же адресу которому присваиваем данные
}                           // проблемы нету так как константность появляется только после
                            // работы конструктора, а исчезает после деструктора

                           КОНСТАНТНЫЕ Ф-ЦИИ В КЛАССЕ

Lesson15CONSTFUNC.cpp

const A operator+ (const A& R) const
// const             A operator+ (const A& R)         const
//(возврат константы)            (аргумент-конст)     (ф-ция работает с конст)
{                              //(правый опер. конст) (левый операнд конст)
  A temp(m_a + R.m_a);
  return temp;
}
ф-ция возвращает константу и ф-ция является константной (const в конце)
только константная ф-ция может работать с константой в классе 
с this (левый операнд) в данном случае
константная ф-ция может быть только членом класса

Д.З. сделать в Array такой же оператор + (константная ф-ция и возвращает конст.)

                        CLASS TEMPLATE (шаблонные классы)

class_template.cpp

template <typename T>
void show (T a)
{
  cout << a << endl;
}


template <typename T>
class Array
{
  ...
};

int main()
{
..
  Array <int> aObj(7); // всегда указываем тип при создании шаблонного класса
  Array <char> aObj(7); 
  Array <double> aObj(7);
  //и так далее, также устроен и вектор
..
}

                     CLASS TEMPLATE SPECIALIZATION

Class_template_specialization.cpp

когда шаблон не подходит для определённого типа создают
специализированный шаблон в котором изменяют работу для этого типа
шаблонные классы прописывают в файликах .hpp и не разделяют объявление
и определение

template<>          //так прописывается специализированный класс,
class Array <char*> //будет работать только если уже есть "общий"
{   
   //...
   //прописывается всё как и для класса для 
   //всех типов но меняется всё под тип char*
   //..
};

                       STL - standart template library



Основне блоки из которых состоит стандартная библиотека:

* Containers - объект способный хранить однотипные элементы и предоставлять
               интерфейс для работы с ними
  Отличаются друг от друга тем как хранят в себе данные
  Структуры хранения данных:
    1) Array [][][]][][] - (+) быстрый доступ к элементу
                           (+) непрерывное размещение (удобно для обработки)
                           (-) сложно вставлять элементы
                           (-) сложное удаление элементов 
    2) Vector [][][][].. - те же + и - что и у массива
                           (+) insertion_back - просто вставлять в конец новый
                                                элемент
    3) List []->[]->[]   - (-) нету быстрого доступа к элементу
                           (+-) непрерывное размещение (иногда ок иногда нет)
                               в зависимости от размера
                           (+) просто удалять элементы (перенапрвить указатель)
                           (+) вставка элементов (перенаправить указатель)
       это однонаправленный список, бывает и двунаправленный.
    4) Tree (set, multiset, map, multimap)
       данные сортируются сразу               []  ROOT (корень)
       при создании этого контейнера         /  \
       налево меньший элемент от           []    []
       корня, направо больший             /  \  /  \
                                         []  [][]  []
         set - без повторений
         multiset - может иметь повторения
         map - в отличии от set каждый узел это пара (key&value)
         multimap - map который может иметь повторения
                           (+-) средняя скорость доступа к элементам
                           (+) быстрая сортировка 
                           (+) простое удаление элементов
                           (+) простая вставка
    5) Stack - последний пришёл первый ушёл 
      | [] A   
      | [] |  
      | [] |   
      | [] |   
      V [] |
    6) quee ..[][][][].. последний пришёл последний ушёл 
       очередь
    7) очередь с приоритетом 
       (вставка в зависимости от id элемента, а не в конец)
* Iterators 

  vector<int>::iterator itb = VC.begin(), // адрес первого элемента контейнера
		        iten = VC.end();  // адрес первого элемента за 
	                                  // пределом контейнера 
                                          // ИТЕРАТОРЫ ВЕДУТ СЕБЯ КАК УКАЗАТЕЛИ
for (itb = VC.begin(); itb != iten; ++itb)
{
cout << *itb << " ";
}
//вместо vector<int>::iterator itb = VC.begin()
//можно написать 
auto itb = VC.begin();

* Algorithms (sort, qsort......)
  
Д.З.
используя из библиотеки <algorithm>
std::sort() и std::find_if() и предикативную ф-цию для sort()
Задача на обработку точности попадания выстрела в мишень
Объект типа ВЫСТРЕЛ состоит из координаты точки, фамилии стрелка 
и расстояния попадания от центра мишени, которое вычисляется в конструкторе
Размер мишени 20 см (радиус), центр мишени точка с координатами (0,0)
Сгенерировать 50 выстрелов которые будут сохранены в векторе и 
вычислить 
1) 3 самых точных попадания
2) процент попадания в "яблочко", радиус которого 5 см
Подсказка: использовать предикативную статическую ф-цию.


Vector.cpp

#include <vector>
using namespace std;
int main()
{
  vector <int> VC; //template class
  for (int i = 0; i < 10; ++i)
  {
    VC.push_back(rand() % 20);
    cout
      << "SIZE: " << VC.size() << endl          //size of elements in a vector
      << "CAPACITY: " << VC.capacity() << endl; //how much element can be written without
                                                //memory allocation (вместимость)
  }
  //использование итераторов Iterators
  //создаём итераторы для вектора VC:
  vector<int>::iterator itb = VC.begin(), // адрес первого элемента контейнера
  iten = VC.end();  // адрес первого элемента за
                    // пределом контейнера
  for (itb = VC.begin(); itb != iten; ++itb)
  {
    cout << *itb << " ";
  }
  return 0;
}































