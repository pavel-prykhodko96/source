DONE Д.З. Доделать задание с потоками

                    CONDITION VARIABLE

Lesson22.cpp

- аналог Event стандарта C++11 для всех платформ
- позволяет создать объект с помощью которого можно 
организовать междупотоковое взаимодействие, общение 
между потоками

std::condition_variable();

имеет ф-цию wait() которая будет ожидать когда
освобоится mutex и можнно задать дополнительное условие
которое будет проверяться
- когда mutex ловится в .wait() то он сразу же отпускается
=> может запуститься сразу много потоков

std::unique_lock<std::mutex> lck(mtx);
  while (!ready) cv.wait(lck); //wait сразу отпускает 
                               //unique_lock
unique_lock в отличии от lock_guard может отпускать 
объект.

notify_one(); - сообщить другим что cond_var свободна,
может быть проблема что это уведомление будет не словлено 
- решение в 

conditionVariable_checkNotificationDelivery.cpp

notify_all();

- в отличии от event работают не только на х86, а и 
на других платформах

std::unique_lock<std::mutex> lck(mtx); //захват mutex`а
while (!ready) cv.wait(lck); //wait сразу отпускает 
                             //unique_lock


DONE Д.З. есть 3 потока которые работает с одним .log 
файлом, сделать так чтобы они записывали данные поочерёдно
использовать condition_variable 


                         EXCEPTIONS

Exceptions.cpp

- исключения которые могут приводить к завершению программы
и требуют обработки в случаях когда это возможно

при выбросе исключения через throw происходит размотка
стека - для всех объектов в блоке try вызываются деструкторы
и удаляются все объекты

если ловятся классы с наследованием, то нужно отлавливать
их в таком порядке

catch(ChildClass & ex)
{
}
catch(BaseClass & ex)
{
}

потому что базовый отлавливает всё сразу.

class bad_alloc - базовый класс ошибки по диапазону
class out_of_range - ошибка доступа

на телефоне есть фотка организации работы с вложенными
ресурсами, а также перебросов с уровня на уровень во
вложенных циклах

Из деструктора выбрасывать исключение нельзя, либо
ловить их нужно там же в деструкторе


                      SMART POINTERS

- объект который создается на стеке и берёт на себя
управление жизнью ресурса и у себя в деструкторе он
этот ресурс освобождает

int *pData = new int[200];
if(condition) 
  throw (1);
delete []pData; // мы сюда можем просто не дойти 

class memGuard
{
public:
	memGuard(int *pData) : m_pData(pData) {};
	~memGuard() { delete[] m_pData; }
private:
	int *m_pData;
};

DONE Д.З. сделать этот класс шаблонным
добавить возможность хранить и удалять один объект
либо массив

в STL есть auto_ptr из C++11, хотя он считается 
устаревающим и в C++17 удалён
* делает то же самое что и memGuard, только для 
всех типов
* не позволяет создать копию объекта 

из-за своих недостатков создали unique_ptr (с C++11)
он перемещает ресурсы с явным указанием

все умные указатели в библиотеке <memory>

если работать с умными указателями то лучше создавать
данные таким образом 
unique_ptr <class> unClass(new class());
чтобы не удалить случайно один и тот же объект,
так как будет ошибка 
для unique_ptr перегружены операторы -> и *
для того чтобы с ним работать как с обычным указателем
.get() - возвращает nullptr или адрес объекта
.release() - передает адрес кому-то другого для пользования
.reset() - удалить данные

при создании умного указателя вторым параметром
в треугольных <> скобках можно передавать параметр
deleter - ф-ция, которая будет вызвана в качестве
деструктора

shared_ptr - ещё один умный указатель, который позволяет
создавать копии (несколько могут ссылаться на один и тот 
же ресурс) объект удаляется только при вызове деструктора
последнего shared_ptr

use_count() - показывает сколько объектов ссылаются

в предыдущих указателях можно только вызывать конструктор
перемещения, но не копирования в привычном смысле

Д.З. написать свой собственный shared_ptr который для кода
в smart_pointer.cpp будет работать также как и библиотечный












































