
                                  LAMBDAS

- ф-ция которая прописывается непосредственно там где требуется её вызов
- часто используется как предикативная в алгоритмах STL
* смысл? - улучшает читаемость кода, т.к. там где она вызывется находится 
всё её тело
* существует оптимизация которая увеличивает быстродействие если применять
лямбду вместо предикативной ф-ции
* лямбда имеет преимущество перед предикативной ф-цией: в неё можно передать
дополнительные параметры для работы
inline (перед прототипом ф-ции) - встраивание тела ф-ции прямо в место вызова
* лямбда имеет это свойство уже изначально 
Синтаксис
[..variables_from_caller_body..] (..parametrs..) {..body..}
(может быть пустой)
sort (.., predSortCrit)
          ------------
                A  
                |
                V
         [](const A&L, const A&R) {return L<R;}
   


int nCountEvenElements = std::count_if(vValues.begin(), vValues.end(),
  [](int el) {return el % 2 == 0; });

int nCountFromDiapason = std::count_if(vValues.begin(), vValues.end(),
  [nLower,nHigher](int el) {return (el >= nLower && el <= nHigher); });

Последний пример нельзя реализовать с предикативной ф-цией
- в неё нельзя передавать переменные
Также в лямбду можно передавать ссылки на переменные
и менять данные этой переменной
Указатели передавать нельзя

Лямбду можно использовать и как предикативную ф-цию:

auto Lamb = [&a](int el)
{
  cout << "a= " << a << endl;
  return el == a;
};
int nCountSMTH = count_if(vValues.begin(), vValues.end(), Lamb);
{
  int a = 28;
  count_if(vValues.begin(), vValues.end(), Lamb);
} 

также может быть: [=] - видеть все переменные объявленные до лямбды 
                        и передать копии 
                  [&] - видеть все переменные объявленные до лямбды
                        и передать ссылки
                  [this] - когда лямбду нужно исползовать внутри 
                           ф-ции-члена класса

Lesson16.cpp


Д.З. 
* применить лямбду для сортировки выстрелов вместо предикативной ф-ции
(статическая ф-ция нужна была чтобы сделать её членом класса к которой просто
получить доступ)
* применить также partial_sort() для 3 элементов (чтобы вывести 3 самых 
точных выстрела)

vValues.erase(remove_if(vValues.begin(), vValues.end(),
  [](int el) {return el % 2 != 0; }), vValues.end());

count_if - считает сколько в последовательности таких=то элементов
remove_if сдвигает неподходящие элементы в конец и возвращает итератор следующего
после последнего подходящего элемента erase очищает контейнер начиная с 
какого-то и заканчивая каким-то элементом

                                   FUNCTOR

- класс, внутри которого перегружен оператор (), за счёт такой перегрузки
объект класса воспринимается как функциональный объект и его можно 
использовать как предикативную ф-цию, но он имеет преимущество над 
предикативной ф-цией - он может иметь определённое состояние от которого
зависит поведение этого объекта (приблизительно тоже самое что передача
дополнительных параметров в лямбдах, только другой синтаксис).

Functor.cpp

class  moreThen
{
public:
  bool operator() (int el) { return el > 10; }
};

int main()
{
  moreThen objcomp;
  int countElements = count_if(VC.begin(), VC.end(), objcomp);
  //вызов для ф-ций из <algorithm> без круглых скобок, в main с круглыми
  //чтобы отработал bool operator() (int el) { return el > 10; }
}

Д.З. для sort в class Shot попробовать лямбду и функтор

Д.З. написать игру (на почте) в консоли, использовать двумерный массив
или вектор, задать шарики-преграды рандомно, прийти к точке самым оптимальным
способом выбрать точку в которую шарику переместиться.

                           INHERITANCE(наследование)

- процесс расширения функционала базового класса (повторение функционала
со своими особенностями)
protected (3-ий тип открытости данных в класса, который обладает такими же
свойствами как и private, но даёт доступ классам-наследникам)

     class A [//public////protected////private//] ->
  -> class B [//public////protected//данные есть но без доступа напрямую] 
(всё то же что есть в public и protected класса A)

Inheritance.cpp

class Parent
{};

class Child: public Parent //or private or protected (разные типа наследования
{..                        //дают разные типы доступа наследникам.
public:
  Child(int n, int m) : Parent(n), m_prMem(m) {} //Parent(n) можно было бы не писать
                                                 //если был бы констр. по умолчанию
..};

{
  Child ch(7, 12);
  ch.show();         //вызов show() из Child даже если в Parent тоже прописана
  ch.Parent::show(); //чтобы вызвать show() из под Parent
}

Д.З. попробовать разные типы наследование (public, private, protected)
и проверить открытость членов класса.

Child ch7(5,6), *pCh;
Parent pr1(8), *pPr;
pPr = &ch7; // OK: присвоить Child указателю Parent
pPr->show();// Parent`s show() 
pCh = &pr1; // Error!


Наследование:

* повторное использование кода
* возможность объединить в одном контейнере разные типы данных
(указатели на разные типы данных) у которых общий родитель (pPr = &ch7)
* полиморфизм 




















