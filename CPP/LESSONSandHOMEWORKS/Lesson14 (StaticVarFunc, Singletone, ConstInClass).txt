PROJECT LESSON14

ВАЖНО: Чтобы перегружать оператор в теле класса ЛЕВЫЙ ОПЕРАНД
должен быть типа этого класса, правый может быть любым
a*b 
a.operator * (b)

Операторы, которые нельзя перегружать:
. :: ?. .*

Не принято перегружать:
& sizeof !=

Для перегрузки оператора для класса вне его тела нужно использовать
инструкцию friend (если члены операнды закрыты)

Операторы, перегрузка которых должна быть как ф-ции-члены класса:
= () [] ->

Если в классе перегружены + и = то += не перегружен всё равно

Д.З.: перегрузить для Array оператор [], чтобы выводил елемент массива
при вызове Array[].



                         STATIC VARIABLES

PROJECT LESSON14STAT_VAR

Global variables (способы объявления):

1 способ:

1.cpp
{
int globalVar = 7; //область видимости: файл в котором она объявлена
}
2.cpp
{
extern int globalVar; //редактор связей находит в проекте эту переменную
                      //в 1.cpp (extern говорит что эти переменные где-то
                      //объявлены в проекте)
}

2 способ: объявить в .h файле и подключить его к .cpp файлам

Static variables:
та же глобальная переменная, но привязана к той области видимости, 
в которой объявлена
Глобальные переменные рождаются до входа в main() и умирают после
завершения main() и порядок создания и смерти таких переменных
не стандартизирован, поэтому их избегают

Статическая переменная в теле ф-ции:

void func()
{
  static int nStatic = 0; //не умрёт
  int regularVar = 0;     //умрёт
}  

при первом вызове ф-ции nStatic инициализируется, а потом будет
игнорироваться при следующих вызовах этой ф-ции, но будет жить.

strtok - пример ф-ции со статической переменной внутри себя
strtok(char* pStr, const char* delim);
"Global variable with modifier"
вернула адрес буквы 'G' и записала себе в staticVar
адрес после 'Global' после первого вызова
  
а потом вызывали её вот так
strtok(NULL, const char* delim);

Д.З.написать свою strtok которая будет работать также как и библиотечная

Статическая переменная в классе:
- так же является глобальной но привязана к области видимости класса
(её видно только членам класса)

A.h
{
  class A
  {
  private:
    int m_a;
    static int m_nStatVar;    
  public:
    A (int n);
    A ();
    ~A();
    static int m_nCountObj;
    static int getStatVar(); //должна тоже быть статической
                             //для возврата значения стат. переменной
  }
}
A.cpp
{
  A::A(int n):m_a(n) { ++m_nCountObj; }
  A::~A() { --m_nCountObj; }
  A::A() { m_a = 0; }
  int A::getStatVar() { return m_nStatVar; }
  int A::m_nStatVar = 7;
  int A::m_nCountObj = 0;
}

#include "A.h"
int main()
{
  cout << A::m_nCountObj << endl; //вот так её можно увидеть
                                  //если она в public разделе
                                  //так можно показать только 
                                  //статическую переменную
                                  //(не создавая объект типа А)
  {
    cout << A::getStatVar() << endl;//get() ф-ция должна быть 
                                    //статической
    A objA(7);
    cout << A::m_nCountObj << endl;
    A objArr [10];
    cout << A::m_nCountObj << endl;
  }
  cout << A::m_nCountObj << endl;
}

*Статическая ф-ция не может обращаться к нестатическим членам класса
*Внутри статической ф-ции нету 'this'

PROJECT LESSON14SINGLETON

Singleton pattern realization as 
the only one resource for the programm:
- например реализация объекта для работы с базой данных

class Singleton
//
{
public:
  Singleton (int size);
  ~Singleton();
  //void; 
private:
  static int* m_pArr;
  static int m_nSize;
  static int m_nCountObj;
}

Д.З. сделать копию синглтона с общим ресурсом который будет объектом
другого класса (один единственный такой объект на всю программу)
Этот объект на который все ссылаются имеет паблик ф-цию и 
реализовать перегрузку оператора стрелка(->) для класса
Singleton которая позволит добраться до ф-ции этого объекта
(мы использовали стрелку для доступа к членам из-под указателя на
объект)

shallow copy - поверхностное копирование, когда копируются данные
только на стеке класса, это выполняется дефолтным конструктором
копирования и оператором присваивания, которые создаёт компилятор.
если класс не создаёт никаких ресурсов и все данные лежат на стеке
(напр.: не выделяет динам. память для массива) то такого копирования
вполне достаточно, если нет то нам самим необходимо прописать констр.
копирования и оператор присваивания и выполнить deep или глубокое
копирование всего (и на стеке класса, и в динамической памяти)

по-умолчанию создаются конструкторы копирования, инициализации,
деструкции и оператор присваивания

Константность в классе
the const variable in a class

class B
{
private:
  const int m_CONSTVAR;
}

становится константой после работы конструктора, перестает существовать
после работы деструктора.

2 способа инициализации константы в классе:

1)В конструкторе в инициализаторе: B(int n): m_CONSTVAR (n);
2)const int m_CONSTVAR = 8;//прямо в блоке класса (в .h, в .cpp)

Если в классе есть константа то оператор присваивания по-умолчанию
генерироваться не будет, то есть при необходимости выполнения прис-
ваивания нужно его прописать явно.

class B
{
public:
  B & operator = (const B & R);
private:
  const int m_CONSTVAR;
  int m_b;
}

B&B::operator = (const B&R) //реализация оператора присваивания
{                           //без удаления лишних даннных
  if (this!=&R)
  { 
    int sizeB = sizeof(B);
    char *pBuff = new char [ sizeB ];
    B temp (R);
    memcpy(pBuff, this, sizeB);
    memcpy(this, &R, sizeB);
    memcpy(&temp, pBuff, sizeB);
    delete []pBuff;
  }
  return *this;
}



































