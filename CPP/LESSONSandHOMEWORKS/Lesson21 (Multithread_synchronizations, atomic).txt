

                          MULTITHREADING
СИНХРОНИЗАЦИЯ

Lesson21SYNC.cpp
При создании Mutex ф-цией
HANDLE hMut = CreateMutexA(0, FALSE, "process name");
Если TRUE то при создании ф-ция где вызвана CreateMutexA
заберёт себе этот Mutex => либо нужно писать FALSE либо
ReleaseMutex чтобы передать следующим ожидающим

ПЕРЕКРЁСТНАЯ СИНХРОНИЗАЦИЯ
 
Lesson21CROSS_THREAD.cpp
Event - объект ядра с помощью которого можно выполнять
посылку сообщений между потоками 
Может давать нескольким потокам команду выполняться
в отличии от MUTEX 

SetEvent - установка Event в свободное состояние -
как ReleaseMutex (переход в сигнальное состояние,
активное состояние)

Для сообщения Между двумя потоками нужно создать
2 Event'а для один посылается одним потоком и получается
другим и наоборот для второго

Д.З. задание на почте

РАБОТА С ПОТОКАМИ С++11
ThreadsC11.cpp
- стандартные инстременты без привязки к Windows

#include <thread>
thread();
thread(thrFun, parametres);
    //(it can be a function, a functor, a lambda)
thread& operator=(thread&& other) noexcept;

- подходит любая ф-ция в качестве потоковой 
(не нужно писать DWORD WINAPI)

void std::thread::joinable() - проверяет привязан ли
этот объект к исполняемому потоку или он пустой
void std::thread::join() - тоже что и WaitForSimpleObj
void std::thread::detach() - отстегнуть потоковый объект 
от испольняемого потока // без этой ф-ции при выходе из
//области видимости поток завершится при работе деструктора


#include <mutex>

std::mutex();
std::mutex::lock(); - захватить - WaitForSingleObj
std::mutex::unlock(); - отпустить - ReleaseMutex

std::lock_guard; - объект класса lock_guard, который
создаётся на основе mutex и этот объект внутри своего
деструктора вызывает unlock для своего mutexa в случае
если испольнение кода дошло до конца области видимости
деструктор вызывается автоматически, а если происходит
выброс исключения до выхода из области видимости, то в
процессе "размотки" стека будет также вызван деструктор
- одна инструкция вместо .lock() - .unlock()
std::unique_lock - тот же lock_guard с расширенным 
функционалом - в отличии от lock_guard может отпустить
mutex не уничтожая объект

                             ATOMIC

- объект, который предоставляет ф-ции выполняющиеся
атомарно, то есть гарантируется что инструкции выполнения
не будут прерваны и выгружены из процессора

DONE Д.З.
задание где мы создавали 4 потока и каждый работал со
своим индексом реализовать с помощью atomic вместо mutex
(на почте тоже есть, посмотреть что там в файлике этом)
в файле на почте - только один из потоков может 
выполнить fetch_add
sleep_for - остановить поток на время

DONE Д.З.
Посмотреть что там с BlockShape и доделать его




