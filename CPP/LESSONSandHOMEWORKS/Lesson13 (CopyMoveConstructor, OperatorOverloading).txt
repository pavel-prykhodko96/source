
для осведомлённости в .h пишем объявление класса
а в .cpp подключаем .h класса, смысл осведомлённости в том,
что в класса выделяется память только для указателя, если
не подключать этот класс

Д.з: доделать бэкап чтобы он в аргументе возвращал size
Сделать возврат кодов ошибок для read и write ф-ций
Сделать чтобы write и read работали с порциями данных

деструктор нужен когда мы выделяем при работе класса
память для информации в куче, если в стеке то не нужно 

Copy Constructor (Конструктор копирования)

- Конструктор копирования это ещё один дефолтный функционал 
класса, который выполняет побитовое копирование объекта 
и вызывается в 4 случаях:

Array ar2(ar1);        //explicit   - явная инициализация
Array ar3 = ar1;       //non-expicit - неявная инициализация
void funct (Array ar); //передаем объект в качестве аргумента ф-ции
return arr;            //передаем объект в качестве возвращаемого знач
                       //Везде выполняется побитовое копирование

RVO - return value optimization

Конструктор копирования необходимо перегружать в том 
случае, когда класс имеет указатель на внешние ресурсы
иначе мы получим 2 объекта которые указывают на один и 
тот же блок ресурсов и при попытке освободить эти ресурсы
дважды в деструкторе мы получим непредвиденное поведение

class Array
{
public: 
  Array (const Array & R)
  {
    m_nSize = R.m_nSize;
    m_nCurInd = R.m_nCurInd;
    m_pArr = new int [R.m_nCurInd];
    memcpy(m_pArr, R.m_pArr, sizeof(int)*R.m_nSize);
    cout << "Copy constructor for " << this << endl;
  }//Мы создали новый массив, указатель которого указывает на
   //Другой участок памяти и деструктор будет вызываться каждый
   //раз для разных участков памяти - ОК 
}

если в классе есть объект другого типа то в конструкторе копирования
в инициализаторе этот объект инициализируется таким образом:

A(const A & R) : m_bObj (R.m_bObj)
{
  ...
}

Если возникает необходимость перегрузить конструктор копирования
то в большинстве случаев перегружают также оператор присваивания.

Перегрузка операторов (Operator Overloading)

- мы можем перегружать только существующие операторы
- мы не можем перегрузть: унарность, бинарность, приоритет оператора

оператор присваивания - функционал по-умолчанию при котором
также выполняется побитовое копирование и соответсвтвенно если
меня не устраивает побитовое копирование, то его также нужно 
перегрузить.

при перегрузке операторов удобно ориентироваться на правила int'а
(представить что будет если операнды будут int'ами)
A A1;
A A2;
    A1 = A2;
это A1.operator = (A2);

A & operator = (const A & R) //перед оператором & потому что по
                             //правилу инта после действий перед 
                             //операцией копирования возвращается
                             //ссылка на перемунную которая хранит 
                             //данные
{
  ~A(); //уничтожаем всё что было в объекте до присваивания
  //copy from R to this
  //and resources
  return *this;
}

Array &Array::operator = (const Array & R)
{
  this->~Array();
  m_nSize = R.m_nSize;
  m_nCurInd = R.m_nCurInd;
  m_pArr = new int[R.m_nCurInd];
  memcpy(m_pArr, R.m_pArr, sizeof(int)*R.m_nSize);
  cout << "Assignment for " << this << endl;
  return *this;
}

Array & operator + (const Array & b)
//a1 + a2 == a1.operator + (a2)
//=>для работы с a1 пишем просто имена членов класса
//а для работы с а2 вызываем члены класса с помощью b.имя_члена
{
..
}

если слева от оператора находится объект нашего типа то такой
оператор может быть перегружен как функция-член класса если
же слева от оператора находится объект не нашего типа то такой 
оператор не может быть членом класса он будет френдом

class A
{
  int m_a;
public:
  A (int n) : m_a(n){}
  friend ostream & operator << (ostream & out, const A & R); 
                    //по тому же принципу используется ссылка
                    //что и для знака =
}

cout << ar1 << endl;

friend ostream& operator<< (ostream& out, const Array& R);
в .h файле

ostream& operator<< (ostream& out, const Array& R)
{
	for (int i = 0; i < R.m_nCurInd; ++i)
	{
		out << R.m_pArr[i] << " ";
	}
	return out;
}

Move Constructor (конструктор перемещения)
- используются в случае когда нам нужна не копия объекта, а объект
который забирает себе ресурсы другого объекта, таким образом 
конструкктор перемещения улучшает выполнения уменьшая расход ресурсов

Array (Array && R) //специально такой синтаксис чтобы понимать что
                   //это констр. перемещения
{
  m_pArr = R.m_pArr;
  m_nSize = R.m_nSize;
  m_nCur = R.m_nCur;
  R.m_pArr = nullptr;
}

если мы хотим запретить работу конструктора копирования то прототип
констр. копированиия прописывают, а тело нет.

B bObj = std::move(bObj); //явно вызвать конструктор перемещения

Д.З:

добавить конструктор перемещения в Array и проверить MemoryLeaks
проверить move assignment






























