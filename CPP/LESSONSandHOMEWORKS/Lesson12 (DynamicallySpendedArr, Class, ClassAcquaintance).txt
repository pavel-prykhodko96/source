
WIN32_FIND_DATA fd;  //For writing data about file
HANDLE pHand = FindFirstFile(cFullWithEnd, &fd); 
//To work with numbers of files in the system 
* имя 
*.* имя.расширение

Динамический саморасширяющийся массив
DYNAMICALY SPENDED ARRAY:

создаём двумерный массив
если не хватает места  для указателей на имена
создаём новый большего размера в который перенаправляем адреса на
имена:

в Windows размер увеличивают в 2 раза:

int nFileListSize = 3;
char **pFileNames = new char *[nFileListSize];
int ind = 0;
WIN32_FIND_DATAA fd;
HANDLE handl = FindFirstFileA("D:\\*.*", &fd);
bool bFileExistance = (INVALID_HANDLE_VALUE != handl);
while (bFileExistance)
{
  if (ind == nFileListSize)
    {
      char ** pTemp = new char *[nFileListSize * 2];
      for (int i = 0; i < nFileListSize; ++i)
      {
        pTemp[i] = pFileNames[i];
      }
      delete[]pFileNames;
      pFileNames = pTemp;
      nFileListSize *= 2;
    }
  int nFileSize = strlen(fd.cFileName) + 1;
  pFileNames[ind] = new char[nFileSize];
  strcpy_s(pFileNames[ind], nFileSize, fd.cFileName);
  ++ind;
  //cout << fd.cFileName << endl;
  bFileExistance = FindNextFileA(handl, &fd);	
}


Class:
- структура для создания объекта, но в отличии от структур по умолчанию
члены-данные будут закрытыми
объект является самодостаточным модулем который полностью обеспечивает
свою жизнедеятельность.

Существуют get и set функции для данных класса.

Конструктор - специальная ф-ция класса, которая вызывается при создании 
обьекта и выполняет начальную инициализацию обьекта
Если конструктор в классе не прописан то его создаёт компилятор:
конструктор по умолчанию (default)
Как только создаём собственный конструктор, констр. по умолчанию не будет
создаваться, его нужно указать явно.
Конструктор может быть перегруженным.
Когда обьект "умирает" вызывается ДЕСТРУКТОР класса, который также 
создаётся по-умолчанию.
Назначение деструктора освободить все ресурсы, которые выделил объект,
нужно прописать это, иначе он не будет ничего удалять!

~Circle (){} деструктор по умолчанию

~Circle ()
{
  cout << "Circle was destructed!" << endl;
}

создание класса (LESSON 12):

Array.cpp
Array.h
ArrayFile.cpp

explicit Array(int size);

explicit: запрет неявного объявление/принуждение к явному объявлению 
класса, например: 
Array ar(9); //ok
Array ar = 9; //error

this: указывает адрес обьекта, используется только внутри реализации 
класса

Д/з: добавить конструктор, который создаёт обьект на основе массива
(ещё один конструктор который принимает массив вместо размера)
аргументы:(int* iArr, int nSize);

Композиция класса
- совместное использование обьектов разного типа
Класс может в качестве члена данных содержать в себе обьект 
другого типа - агрегирование

продолжение Class.cpp в CompositionInClass.cpp

Classes Acquaintance - осведомлённость классов

когда в классе объявляется указатель на объект другого типа -
ОСВЕДОМЛЁННОСТЬ - она более гибкая, так как под указатель можно 
создать объект только при необходимости

если создаём объект класса А в классе B, класс А нужно прописать или
подключить через А.h

если создаём указатель на класс A в классе B просто объявляем:
class A;

Есть 2 возможности установить значение для указателя на объект чужого
типа: 
1. Конструктор (создаваемый на основе указателя на объект другого типа)
2. set-ф-ция (позволяющая установить значение указателя в момент
выполнения программмы, когда в нём возникла необходимость)

Д.З: Записать композицию классов Point и Line (линия, 2 объекта типа
Point, добавить ф-цию вычисления длины) 

Д.З: Создать класс BackUp
 
class Array
int * m_pArr;
BackUp * m_pBackUp;

class BackUp
{
public:
  void save (char *pFileName, char *data, int size);
  int *read (char *pFileName, int size);
}
который умеет читать данные из файла и записывать в него данные

void setBackUp(BackUp * pBU)
void writeToFile()
{
  if (m_pBackUp != nullptr)
  m_pBackUp.save(пробел,m_pArr,m_nCurInd);
}
класс Array - хранит
BackUp - пишет (хранится в Array на него ссылка)
нужно подключить к main Array.h
в котором подключен BackUp.h







